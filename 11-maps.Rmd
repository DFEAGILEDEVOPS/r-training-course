# Maps

Maps in R are best plotted using <span class="code">ggplot</span> - which is good, because we already know how to use that! However, the new thing about maps is the sort of data we'll be using - as well as having data about certain variables, this data has a location attached to it too.

First, we need to load in the packages we need. We'll need the following packages:

* <span class="code">tidyverse</span>, as this contains <span class="code">ggplot2</span> for plotting and <span class="code">dplyr</span> for data manipulation
* <span class="code">rgdal</span>, a package for loading in spatial data
* <span class="code">broom</span>, a package for converting spatial data into dataframes to be plotted in <span class="code">ggplot2</span>

<div class="activity"><b>Activity A11.1:</b>

1. Install <span class="code">rgdal</span>
2. Install <span class="code">broom</span>
3. Use <span class="code">library()</span> to load <span class="code">tidyverse</span>, <span class="code">rgdal</span>, and <span class="code">broom</span>
</div>

## Loading in geospatial data

Geospatial data comes in three forms:

* Polygons (shapes) 
* Lines
* Points

Polygons and points are the most common (geospatial line data only really features when relating to travel infrastructure or people movements), so we'll focus on these two.

Point, polygon, and line data can come in a number of different data formats, but the msot common is a 'shapefile' with a <span class="code">.shp</span> suffix. We can use the <span class="code">rgdal</span> library to load in shapefiles. Firstly, we're going to load the names of location of major UK cities using the <span class="code">readOGR</span> function.

```{r sec11_1}
cities <- "data/SHPs/england_cities.shp" %>% 
  readOGR()
```

Plotted, the cities look like this:

```{r sec11_2,echo=FALSE}
plot(cities,col="red")
```

...which looks vaguely like the UK!

You'll see <span class="code">cities</span> is a <span class="code">SpatialPointsDataFrame</span> class object. The essentially means it's a dataframe with spatial data attached.

<div class="activity"><b>Activity A11.2:</b> Click the blue circle to the left of <span class="code">cities</span> to open up the object. You'll see there's an attribute within <span class="code">cities</span> called <span class="code">data</span>, and another attribute called <span class="code">coords</span>.

Access these by typing <span class="code">cities@</span> and then whichever of the attributes you want to view.
</div>

We can also use <span class="code">readOGR</span> to load in polygon data. The file we're going to use is one containing the boundaries of Local Authorities (LAs) in England, called <span class="code">England_LA_2016.shp</span>.

```{r sec11_3,eval=FALSE}
england <- "data/SHPs/england_la_2016.shp" %>% 
  readOGR()
```

This is a <span class="code">SpatialPolygonsDataFrame</span>, which makes sense!

However, if we plot the LAs alongside the cities, the don't match up.

```{r sec11_4,echo=FALSE}
plot(england) +
  plot(cities,add=T,col="red")
```

What we have here is all of the city points plotted down in the bottom lefthand corner (although you can only see one) over the LA map. This is because the cities data and the LA data use different 'coordinate systems'.

## Coordinate systems

At their most basic level, coordinates are just numbers that represent a location, where all the points within that set follow the same form. With that in mind, we can use different sets of numbers, or systems, to represent the location of a point. There are a lot of coordinate systems that are used in mapping, but the most common that you'll come across when mapping UK data are:

* WGS84 (EPSG4326): This is the standard Latitude and Longitude coordinate system to map global data, developed in 1984. It makes the assumption that the earth is a perfect sphere (it's actually a bit elliptical - wider at the sides), and Longitude (on the x axis) goes between -180 and 180 (degrees), with 0 being the Meridian Line in Greenwich, London. Latitude (on the y axis) again goes between -180 and 180, with 0 on the Equator.
* OSGB36 (EPSG27700): This is a grid system, with units in metres, specific to the UK. It's origin is about 100km west of Lands End, roughly level with the most southerly point of the mainland Britain, Lizard Point. It assumes that the British Isles are on a completely flat plane (which of course they aren't). On the x axis are Eastings and on the y axis are Northings. The largest coordinate value is (800000,1300000).


<div class="tip"><b>Tip:</b>
The EPSG codes are codees from the now defunct European Petroleum Survey Group, and are a common code for different coordinate systems. These are the codes that we'll use to change the coordinate systems. For more information on codes click [here](http://www.epsg-registry.org/). 
</div>


Let's check which coordinate systems <span class="code">cities</span> and <span class="code">england</span> are on.

```{r sec11_5}
#Find out the coordinate system of cities
cities@proj4string
```

So, <span class="code">cities</span> is on WGS84 - we can see from its <span class="code">datum</span> (origin) attribute.

```{r sec11_6}
#Find out the coordinate system of england
england@proj4string
```

So, <span class="code">england</span> is on OSGB36 - again we can see from its <span class="code">datum</span> attribute.

Therefore, we need to translate one of the coordinate systems into the other. We're going to convert <span class="code">cities</span> into the OSGB36 coordinate system, because it's a bit more of an intuitive system to use, using a grid in metres instead of degrees.

```{r sec11_7}
cities <- cities %>% 
  spTransform(CRS("+init=epsg:27700"))
```

Let's break this down:

* <span class="code">cities</span> is our object name, and the first ingredient in our 'recipe' using pipes. We're essentially updating <span class="code">cities</span>.
* <span class="code">spTransform</span> is a function for transforming spatial objects' coordinate systems
* <span class="code">CRS</span> stands for 'Coordinate Reference System' - this takes an argument which is a string containing the EPSG code of the coordinate system we want to convert to, which in this instance is EPSG27700

<div class="activity"><b>Activity A11.1:</b> After you've run the code above, recheck which coordinate system <span class="code">cities</span> is on.
</div>

Now if we replot <span class="code">cities</span> and <span class="code">england</span>, we'll see they line up more as we'd expect.

```{r sec11_8,echo=FALSE}
plot(england) +
  plot(cities,add=T,col="red")
```

## Transforming mapping data

As mentioned, we're going to be using <span class="code">ggplot</span> to plot the maps. However, <span class="code">ggplot</span> takes dataframes, and currently we have spatial dataframes, so that's not going to fly.

What we need to do is convert our spatial dataframes into normal dataframes. There are two methods for this:

* For point data we can just convert it straight to a normal dataframe, and select the coordinates and any other required columns (e.g. labels)
* For polygon data we need to use a <span class="code">broom</span> function called <span class="code">tidy</span>, which breaks a polygon up into a series of lines, and creates a dataframe where each row is a coordinate of the start of one line and the stop of another, as well as a column detail which group (in this instance a Local Authority) it's part of

Let's deal with the point data first.

```{r sec11_9}
cities_df <- cities %>% 
  data.frame()
```

Which creates something that looks like this:

```{r sec11_10}
head(cities_df)
```

<div class="activity"><b>Activity A11.2:</b> We need to do a bit of cleaning on this dataframe. Select only the first four columns, rename <span class="code">Lbl_Pst</span> as <span class="code">label_position</span>, <span class="code">coords.x1</span> as <span class="code">easting</span> and <span class="code">coords.x2</span> as <span class="code">northing</span>. The second column relates to the position of the label relative to the point marker.

## Point maps

## Polygon maps

```{r}
england <- spTransform(england, CRS("+init=epsg:27700"))
?CRS
england %>% writeOGR(dsn="data",layer="england_la_2016", driver="ESRI Shapefile")
?writeOGR

england <- "data/SHPs/England_LA_2016.shp" %>% 
  readOGR() %>% 
  tidy() %>% 
  as.tbl() %>% 
  inner_join(("data/SHPs/England_LA_2016.shp" %>% 
  readOGR())@data %>% mutate(id = rownames(("data/SHPs/England_LA_2016.shp" %>% 
  readOGR())@data)),"id") %>% 
  dplyr::select(Easting = long,
                Northing = lat,
                LA15NM,
                LA15CD,
                group)

cities <- "data/SHPs/england_cities.shp" %>% 
  readOGR() %>%
  spTransform(CRS("+init=epsg:27700")) %>% 
  data.frame() %>% 
  select(City,
         Easting = coords.x1,
         Northing = coords.x2)

ggplot()+
  geom_polygon(data=england,
               aes(Easting,Northing,group=group),
               col="grey",
               fill=NA) +
  geom_point(data=cities,
             aes(Easting,Northing),
             col="red") +
  coord_equal() +
  theme_minimal() +
  geom_text(data=cities,
            aes(Easting,Northing,label=cities$City),
            check_overlap = TRUE,
            col="blue",
            hjust = 1.1,
            vjust=0.3)
```

## Point maps
```{r,eval=FALSE}
Wiltshire <- "data/SHPs/England_LA_2016.shp" %>% 
  readOGR() %>% 
  subset(LA15NM == "Wiltshire") %>% 
  fortify(region="LA15NM") %>% 
  as.tbl() %>% 
  dplyr::select(Easting = long,
                Northing = lat,
                LA15NM = id,
                group)
  
ggplot() +
  geom_polygon(data=Wiltshire,aes(Easting,Northing),col="grey",fill=NA) +
  coord_equal() +
  theme_minimal() +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.title=element_blank())

wiltshire_schools <- "data/wiltshire_schools.csv" %>% read_csv()

wiltshire_schools %>% write_csv("wiltshire_schools.csv")

ggplot() +
  geom_point(data=wiltshire_schools,aes(Easting,Northing,size=Tot_Workforce_HC,
                                        col=School_Phase)) +
  geom_polygon(data=Wiltshire,aes(Easting,Northing),col="grey",fill=NA) +
  coord_equal() +
  theme_minimal() +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.title=element_blank())
```

## Chloropleth maps

```{r,eval=FALSE}
library(rgdal)

England <- readOGR("data/SHPs/England_Regions.shp")
plot(England)

region_ave_salary <- "data/region_ave_salary.csv" %>% 
  read_csv()

Reg_England_df <- England %>% 
  fortify(region="rgn16nm") %>% 
  as.tbl() %>% 
  dplyr::select(Easting = long,
                Northing = lat,
                Region = id,
                group) %>% 
  left_join(region_ave_salary,c("Region"="Government_Office_Region_Name"))

ggplot() +
  geom_polygon(data=Reg_England_df,aes(Easting,Northing,
                                       group=group,
                                       fill=ave_sal),
               col="white") +
  coord_equal() +
  theme_minimal() +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.title=element_blank())
```
